#!/usr/bin/python

import sys, os, os.path, string, glob, math
import random
import time
import tempfile
import subprocess
import unittest


# A base class for our unit tests -- defines snapshot/restore for the pool
class grid_scale_test(unittest.TestCase):
    def setUp(self):
        self.snapshot = "grid_scale_test_snapshot_%s" % (time.time())
        sys.stdout.write("Snapshotting current pool config to %s:\n" % (self.snapshot))
        subprocess.call(["condor_configure_pool", "--take-snapshot", self.snapshot])

    def tearDown(self):
        sys.stdout.write("Restoring pool config from %s:\n" % (self.snapshot))
        subprocess.call(["condor_configure_pool", "--load-snapshot", self.snapshot])        


# A prototype "micro" scale test, to run on a personal condor
class grid_scale_test_micro(grid_scale_test):
    def setUp(self):
        grid_scale_test.setUp(self)
        # class specific setup goes after parent class

    def tearDown(self):
        # class specific teardown goes before parent class
        grid_scale_test.tearDown(self)
        
    def test1(self):
        # this unit test should pass
        sys.stdout.write("sleeping...\n")
        time.sleep(10)



if __name__ == "__main__":
    # Tentatively, I don't think it's a good idea to run all test cases 
    # for our purposes, so if no args are given I'll output usage
    if len(sys.argv) < 2:
        sys.stderr.write("*** The 'no-argument' default (run all tests) has been disabled for this test harness:\n\n")
        sys.argv.append("-h")        

    # This provides nice default command-line facilities for running
    # any unit tests defined in this module/command.  To see the usage,
    # run this file with '-h' or '--help' option.
    unittest.main()
